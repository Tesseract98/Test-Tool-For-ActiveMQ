# TestToolForActiveMQ

#Задание#

MQ Loader - тестовый инструмент, генерирующий поток сообщений для тестируемой системы, которая получает сообщения через очередь ActiveMQ.

Программа должна запускаться из командной строки. Необходимые для работы программы настройки будут храниться в текстовом файле. Можно использовать формат Properties.

Сообщения, которые должна генерировать программа, имеют текстовый формат. Пользователь описывает сообщение с помощью шаблона. Этот файл содержит текст сообщения с формулами для генерации значений полей. Для вычисления формул должна использоваться библиотека MVEL.

В формулах могут использоваться следующие функции:<br/>
● number - генерация случайного целого числа;<br/>
● decimal - генерация случайного десятичного числа;<br/>
● id - генерация случайной последовательности символов (для идентификаторов);<br/>
● dateTime - генерация строки, содержащей дату и время в указанном формате с заданным сдвигом в днях;<br/>
● fileValue - выбор случайного значения из текстового файла;<br/>
● uniqueFlieValue - выбор любого случайного значения из файла кроме того, которое ранее выбиралось из этого файла для генерации текущего сообщения.

Сообщения должны отправляться по плану, описанному в файле с настройками.<br/> 
Пример плана: 100mps/10s;200mps/10s;300mps/20s.<br/>
Это означает, что первые 10 секунд сообщения должны отправляться со скоростью 100 сообщений в секунду, следующие 10 - 200 сообщений в секунду и последние 20 секунд - 300 сообщений в секунду. 
Для организации работы по плану нужно использовать шаблон параллельного программирования Producer-Consumer. 
В данной задаче Producer - поток, генерирующий сообщения согласно плану. Consumer - поток, отправляющий сообщения. 
Для связи потока-генератора и потока-отправителя должна использоваться BlockingQueue, куда генератор будет складывать сообщения. 
Нужно посмотреть, какая из реализаций BlockingQueue в Java лучше подходит для задачи отправки по плану.

Статистика по реальной отправке сообщений должна выводиться в лог каждую секунду. Она должна содержать:
● общее количество отправленных на данный момент сообщений;
● количество сообщений, отправленных за последнюю секунду.
Для ведения лога можно использовать библиотеку log4j. Статистика должна выводиться с уровнем info. Кроме того, в лог должны попадать сообщений об ошибках. А с уровнем debug должны логгироваться все отправляемые сообщения.
Для сборки проекта необходимо использовать Gradle.
Полезные ссылки
● Скачать ActiveMQ: -https://activemq.apache.org/components/classic/download/;
● Как запустить ActiveMQ и зайти в веб-консоль для управления: -https://activemq.apache.org/getting-started#StartingActiveMQStartingActiveMQ;
● Пример кода для работы с ActiveMQ: -https://activemq.apache.org/hello-world;
● О библиотеке MVEL: -http://mCompiledTemplate vel.documentnode.com/;
● Создание простого проекта с Gradle: -https://guides.gradle.org/building-java-applications/;

Пример шаблона сообщения

{1:F01ZYGCGB20XXXX0919155231}{2:O5182138171206@{fileValue('tradeSources')}11167792461712062138N}{4:<br/>
:16R:GENL<br/>
:20C::SEME//@{id(16)}<br/>
:23G:NEWM<br/>
:22F::TRTR//TRAD<br/>
:16R:LINK<br/>
:20C::COMM//SWIFT@{id(11)}<br/>
:16S:LINK<br/>
:16S:GENL<br/>
:16R:CONFDET<br/>
:98C::TRAD//@{dateTime('yyyyMMddhhmmss')}<br/>
:98A::SETT//@{dateTime('yyyyMMdd',2)}<br/>
:90B::DEAL//ACTU/@{fileValue('currencies')}@{decimal(0,99999999, 2)}<br/>
:94B::TRAD//EXCH/@{fileValue('tradingVenues')}<br/>
:22H::BUSE//BUYI<br/>
:22H::PAYM//APMT<br/>
:16R:CONFPRTY<br/>
:95R::BUYR//@{uniqueFileValue('firms')}<br/>
:20C::PROC//Buy Oref<br/>
:16S:CONFPRTY<br/>
:16R:CONFPRTY<br/>
:95R::SELL//@{uniqueFileValue('firms')}<br/>
:20C::PROC//Sell Oref<br/>
:16S:CONFPRTY<br/>
:36B::CONF//UNIT/@{number(1,9999)}<br/>
:35B:ISIN @{fileValue('instruments')}<br/>
:16R:FIA<br/>
:16S:FIA<br/>
:16S:CONFDET<br/>
:16R:SETDET<br/>
:22F::SETR//TRAD<br/>
:16S:SETDET<br/>
-}{5:{MAC:12345678}{CHK:123456789ABC}}<br/>

#Поля:#

TRAD (tradeDate)	Trade date - фактическая дата осуществления сделки.<br/>
Требование к полю: дата в формате - 'yyyyMMddhhmmss'.<br/>
Пример: 20191201141122.

SETT (settlementDate)	Settlement date - дата завершения конкретной сделки, в эту дату покупатель должен внести оплату за совершение сделки, а продавец должен предоставить финансовые инструменты. <br/>
Обычно, для акций, settlement date наступает через два дня после осуществления сделки T+2.<br/>
Требование к полю: дата в формате - 'yyyyMMdd'.<br/>
Пример: 20190601.

currencies	Валюта в которой трейдятся инструменты.<br/>
Требование к полю: 3 символа, буквенный код.<br/>
Пример: RUB, GBP, AUD.<br/>

tradingVenues	Платформы где стороны покупают и продают (осуществляют сделки) инструменты.<br/>
Требование к полю: 4 символа, буквенный код.<br/>
Пример: CSOM, IART, ETBA.<br/>

firms	Кодовое название компании.<br/>
Требование к полю: 6 - 11 символов, буквенно-цифровой код.<br/>
Пример: PYTEROCHKA1, MAC123, 321PEK.<br/>

instruments	Осуществляя операции на финансовом рынке предприятие выбирает соответствующие финансовые инструменты их проведения.<br/> Финансовые инструменты представляют собой разнообразные обращающиеся финансовые документы, имеющие денежную стоимость, с помощью которых осуществляются операции на финансовом рынке. <br/>
Например Акции.<br/>
Требование к полю: 12 символов, буквенно-цифровой код.<br/>
Пример: OV03054473OV, DMI00T78R55Y, 54P3YT343512

#Как работать с MVEL#

import org.mvel2.templates.CompiledTemplate;<br/>
import org.mvel2.templates.TemplateCompiler;<br/>
import org.mvel2.templates.TemplateRuntime;<br/>

import java.util.HashMap;<br/>
import java.util.Map;<br/>

public class MvelTest<br/>
{<br/>
	public static void main(String[] args)<br/>
	{<br/>
		Map<String, Object> vars = new HashMap<>();<br/>
		vars.put("A", 1);<br/>
		vars.put("B", 5);<br/>
		CompiledTemplate template = TemplateCompiler.compileTemplate("@{max(A, B)}");<br/>
		System.out.println(TemplateRuntime.execute(template, new MvelTest(), vars));<br/>
	}<br/>
	
	public int max(int a, int b)<br/>
	{<br/>
		return Math.max(a, b);<br/>
	}<br/>
}<br/>
